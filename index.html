<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trigonometry Explorer (Dual Model)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&display=swap');
        :root {
            --bg-color: #000000;
            --canvas-bg-color: #1a1a1a;
            --controls-bg-color: #1f1f1f;
            --text-color: #f0f0f0;
            --axis-color: #ffffff;
            --grid-color: #444444;
            --circle-color: #ffffff;
            --cos-color: #ff0000;
            --sin-color: #00ff00;
            --tan-color: #ffff00;
            --sec-color: #9932cc;
            --cot-color: #ffa500;
            --csc-color: #4db8ff;
            --point-color: #4da6ff;
            --angle-color: #ffffff;
            --checkbox-color: #00bfff; /* Deep sky blue / cyan */
        }

        body {
            font-family: 'Space Grotesk', sans-serif; background-color: var(--bg-color); color: var(--text-color);
            margin: 0; overflow-y: auto; /* Allow scrolling */
            display: flex; justify-content: flex-start; align-items: center;
            min-height: 100vh; flex-direction: column;
        }

        .container {
            display: flex;
            flex-direction: column; /* Mobile-first: stack vertically */
            align-items: center;
            gap: 20px;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
        }

        #trigCanvas {
            background-color: var(--canvas-bg-color);
            border: 1px solid var(--grid-color);
            cursor: grab;
            width: 95%; /* Responsive width */
            max-width: 700px; /* Max size like original */
            height: auto;
            aspect-ratio: 1 / 1; /* Maintain square shape */
        }

        .controls {
            display: flex; flex-direction: column;
            width: 95%; /* Responsive width */
            max-width: 500px; /* Sensible max width on mobile/tablet */
            padding: 20px;
            background-color: var(--controls-bg-color);
            border-radius: 8px; border: 1px solid #444;
            box-sizing: border-box;
        }
        .controls h2 { margin-top: 0; text-align: center; color: var(--tan-color); }
        
        .model-switcher { display: flex; margin-bottom: 20px; border-radius: 5px; border: 1px solid #555; overflow: hidden; }
        .model-switcher input { display: none; }
        .model-switcher label {
            flex: 1; text-align: center; padding: 8px; cursor: pointer;
            background-color: #333; transition: background-color 0.2s; user-select: none; font-size: 0.9em;
        }
        .model-switcher input:checked + label { background-color: #5c5c5c; font-weight: bold; }

        .slider-container, .reset-container { display: flex; flex-direction: column; align-items: center; margin-bottom: 10px; }
        .slider-container label { font-size: 1.1em; padding: 8px; }
        #resetButton { width: 100%; padding: 8px 15px; font-size: 1em; font-weight: bold; color: var(--text-color); background-color: #333; border: 1px solid #555; border-radius: 5px; cursor: pointer; transition: background-color 0.2s; }
        #resetButton:hover { background-color: #555; }
        
        fieldset { border: 1px solid #444; border-radius: 5px; padding: 10px 15px; margin-top: 20px; }
        legend { padding: 0 10px; font-weight: bold; color: var(--text-color); }

        .checkbox-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        .checkbox-item { display: flex; align-items: center; font-size: 0.9em; }
        .checkbox-item[data-model-specific] { display: none; } /* Specific items hidden by default */
        
        .checkbox-item input[type="checkbox"] { /* Custom checkbox style */
            appearance: none; -webkit-appearance: none;
            background-color: #333; border: 1px solid #777;
            width: 16px; height: 16px; border-radius: 3px;
            position: relative; cursor: pointer; margin-right: 8px;
        }
        .checkbox-item input[type="checkbox"]:checked {
            background-color: var(--checkbox-color); border-color: var(--checkbox-color);
        }
        .checkbox-item input[type="checkbox"]:checked::after {
            content: '✔'; font-size: 12px; font-weight: bold; color: white;
            position: absolute; left: 50%; top: 50%;
            transform: translate(-50%, -50%);
        }

        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        td { padding: 8px; text-align: left; border-bottom: 1px solid #444; }
        td:nth-child(2) { font-family: 'Courier New', Courier, monospace; font-weight: bold; text-align: right; }
        table tr { transition: opacity 0.3s; }
        table tr[data-model-specific] { display: none; } /* Specific items hidden by default */
        .color-swatch { display: inline-block; width: 12px; height: 12px; margin-right: 8px; vertical-align: middle; border: 1px solid #555; }

        /* Desktop Layout */
        @media (min-width: 1024px) {
            body {
                justify-content: center;
                overflow: hidden; /* Re-hide scrollbar on desktop */
            }
            .container {
                flex-direction: row;
                align-items: flex-start;
                padding: 20px;
            }
            .controls {
                width: 300px; /* Restore fixed width on desktop */
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <canvas id="trigCanvas"></canvas>
        <div class="controls">
            <h2>Trigonometry Explorer</h2>

            <div class="slider-container">
                <label>Angle θ: <span id="angleValue">40.0°</span></label>
            </div>
            <div class="reset-container"> <button id="resetButton">Reset </button> </div>
            
            <fieldset>
                <legend>Display Ratios</legend>
                <div class="checkbox-grid">
                    <div class="checkbox-item"><input type="checkbox" class="ratio-checkbox" id="showSin" checked><span class="color-swatch" style="background-color: var(--sin-color);"></span><label for="showSin">sin(θ)</label></div>
                    <div class="checkbox-item"><input type="checkbox" class="ratio-checkbox" id="showCsc"><span class="color-swatch" style="background-color: var(--csc-color);"></span><label for="showCsc">csc(θ)</label></div>
                    <div class="checkbox-item"><input type="checkbox" class="ratio-checkbox" id="showCos" checked><span class="color-swatch" style="background-color: var(--cos-color);"></span><label for="showCos">cos(θ)</label></div>
                    <div class="checkbox-item"><input type="checkbox" class="ratio-checkbox" id="showSec"><span class="color-swatch" style="background-color: var(--sec-color);"></span><label for="showSec">sec(θ)</label></div>
                    <div class="checkbox-item"><input type="checkbox" class="ratio-checkbox" id="showTan" checked><span class="color-swatch" style="background-color: var(--tan-color);"></span><label for="showTan">tan(θ)</label></div>
                    <div class="checkbox-item"><input type="checkbox" class="ratio-checkbox" id="showCot"><span class="color-swatch" style="background-color: var(--cot-color);"></span><label for="showCot">cot(θ)</label></div>
                </div>
            </fieldset>

            <table>
                <tbody>
                    <tr data-ratio="angle-deg"><td>θ (degrees)</td><td id="angle-deg">40.0</td></tr>
                    <tr data-ratio="angle-rad"><td>θ (radians)</td><td id="angle-rad">0.6981</td></tr>
                    <tr class="table-divider"><td colspan="2" style="padding: 0;"><hr style="border-color: #444; margin: 0;"></td></tr>
                    <!-- Common Ratios -->
                    <tr><td><span class="color-swatch" style="background-color: var(--cos-color);"></span>cos(θ)</td><td id="val-cos">0.7660</td></tr>
                    <tr><td><span class="color-swatch" style="background-color: var(--sin-color);"></span>sin(θ)</td><td id="val-sin">0.6428</td></tr>
                    <!-- Tan/Sec Specific -->
                    <tr data-model-specific="tan_sec"><td><span class="color-swatch" style="background-color: var(--tan-color);"></span>tan(θ)</td><td id="val-tan">0.8391</td></tr>
                    <tr data-model-specific="tan_sec"><td><span class="color-swatch" style="background-color: var(--sec-color);"></span>sec(θ)</td><td id="val-sec">1.3054</td></tr>
                    <!-- Cot/Csc Specific -->
                    <tr data-model-specific="cot_csc"><td><span class="color-swatch" style="background-color: var(--cot-color);"></span>cot(θ)</td><td id="val-cot">1.1918</td></tr>
                    <tr data-model-specific="cot_csc"><td><span class="color-swatch" style="background-color: var(--csc-color);"></span>csc(θ)</td><td id="val-csc">1.5557</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('trigCanvas');
            const ctx = canvas.getContext('2d');
            const DEFAULT_ANGLE = 40;
            let currentModel = 'tan_sec';
            let angleDeg = DEFAULT_ANGLE; // Main state for the angle
            let isDragging = false;

            const ui = {
                angleValueSpan: document.getElementById('angleValue'),
                angleDegTd: document.getElementById('angle-deg'),
                angleRadTd: document.getElementById('angle-rad'),
                modelSwitchers: document.querySelectorAll('input[name="model"]'),
                resetButton: document.getElementById('resetButton'),
                checkboxes: {
                    cos: document.getElementById('showCos'), sin: document.getElementById('showSin'),
                    tan: document.getElementById('showTan'), sec: document.getElementById('showSec'),
                    cot: document.getElementById('showCot'), csc: document.getElementById('showCsc'),
                },
                valTds: {
                    cos: document.getElementById('val-cos'), sin: document.getElementById('val-sin'),
                    tan: document.getElementById('val-tan'), sec: document.getElementById('val-sec'),
                    cot: document.getElementById('val-cot'), csc: document.getElementById('val-csc'),
                }
            };

            // These will be updated on resize
            let W, H, originX, originY, unitRadius;
            const style = getComputedStyle(document.documentElement);
            
            function drawTanSecModel(angleRad, values) { /* ... unchanged from previous version ... */ }
            function drawCotCscModel(angleRad, values) { /* ... unchanged from previous version ... */ }
            
            function drawSimulation(currentAngleDeg) {
                if (!W) return; // Don't draw if canvas size not set
                const angleRad = currentAngleDeg * Math.PI / 180;
                const epsilon = 1e-10;
                const values = {
                    sin: Math.sin(angleRad), cos: Math.cos(angleRad),
                    tan: (Math.abs(Math.cos(angleRad)) < epsilon) ? Infinity : Math.tan(angleRad),
                    sec: (Math.abs(Math.cos(angleRad)) < epsilon) ? Infinity : 1 / Math.cos(angleRad),
                    cot: (Math.abs(Math.sin(angleRad)) < epsilon) ? Infinity : 1 / Math.tan(angleRad),
                    csc: (Math.abs(Math.sin(angleRad)) < epsilon) ? Infinity : 1 / Math.sin(angleRad),
                };

                ctx.clearRect(0, 0, W, H);
                drawAxesAndGrid();
                
                const pX = originX + values.cos * unitRadius, pY = originY - values.sin * unitRadius;

                ctx.strokeStyle = style.getPropertyValue('--circle-color');
                ctx.lineWidth = 2.5; ctx.beginPath(); ctx.arc(originX, originY, unitRadius, 0, 2 * Math.PI); ctx.stroke();
                
                ctx.strokeStyle = style.getPropertyValue('--axis-color');
                ctx.lineWidth = 1.5; ctx.setLineDash([4, 4]);
                ctx.beginPath(); ctx.moveTo(originX + unitRadius, 0); ctx.lineTo(originX + unitRadius, H); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(originX - unitRadius, 0); ctx.lineTo(originX - unitRadius, H); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, originY - unitRadius); ctx.lineTo(W, originY - unitRadius); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, originY + unitRadius); ctx.lineTo(W, originY + unitRadius); ctx.stroke();
                ctx.setLineDash([]);
                
                if (currentModel === 'tan_sec') drawTanSecModel(angleRad, values);
                else drawCotCscModel(angleRad, values);
                
                ctx.strokeStyle = style.getPropertyValue('--angle-color');
                ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(originX, originY, 40, 0, -angleRad, angleRad > 0); ctx.stroke();
                ctx.fillStyle = style.getPropertyValue('--angle-color');
                ctx.font = "18px Arial"; ctx.fillText("θ", originX + 55 * Math.cos(-angleRad / 2), originY + 55 * Math.sin(-angleRad / 2));
                ctx.fillStyle = style.getPropertyValue('--point-color');
                ctx.beginPath(); ctx.arc(pX, pY, 10, 0, 2 * Math.PI); ctx.fill();
                
                ui.angleValueSpan.textContent = `${parseFloat(currentAngleDeg).toFixed(1)}°`;
                ui.angleDegTd.textContent = parseFloat(currentAngleDeg).toFixed(1);
                ui.angleRadTd.textContent = angleRad.toFixed(4);
                Object.keys(ui.valTds).forEach(key => {
                    const val = values[key];
                    if (ui.valTds[key]) ui.valTds[key].textContent = isFinite(val) ? val.toFixed(4) : "undef.";
                });
            }

            function updateControlsForModel() {
                const showModel = currentModel;
                const hideModel = (showModel === 'tan_sec') ? 'cot_csc' : 'tan_sec';
                document.querySelectorAll(`[data-model-specific="${showModel}"]`).forEach(el => el.style.display = '');
                document.querySelectorAll(`[data-model-specific="${hideModel}"]`).forEach(el => el.style.display = 'none');
            }

            // --- FULL HELPER FUNCTIONS ---
            const drawArrow = (x, y, dx, dy) => {
                const headlen = 10; const angle = Math.atan2(dy, dx);
                ctx.moveTo(x, y); ctx.lineTo(x - headlen * Math.cos(angle - Math.PI / 6), y - headlen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(x, y); ctx.lineTo(x - headlen * Math.cos(angle + Math.PI / 6), y - headlen * Math.sin(angle + Math.PI / 6));
            };
            const drawAxesAndGrid = () => {
                ctx.strokeStyle = style.getPropertyValue('--grid-color');
                ctx.lineWidth = 0.5;
                for (let i = -5; i <= 5; i++) {
                    if (i === 0) continue;
                    const x = originX + i * (unitRadius/2); const y = originY + i * (unitRadius/2);
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
                }
                ctx.strokeStyle = style.getPropertyValue('--axis-color');
                ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.moveTo(0, originY); ctx.lineTo(W, originY); ctx.stroke();
                drawArrow(W, originY, 1, 0); drawArrow(0, originY, -1, 0);
                ctx.beginPath(); ctx.moveTo(originX, 0); ctx.lineTo(originX, H); ctx.stroke();
                drawArrow(originX, 0, 0, -1); drawArrow(originX, H, 0, 1);
            };
            drawTanSecModel = (angleRad, values) => {
                const { cos, sin, tan, sec } = values;
                const pX = originX + cos * unitRadius, pY = originY - sin * unitRadius;
                const tan_line_x_unit = (cos >= 0) ? 1 : -1;
                const tan_line_x_pixels = originX + tan_line_x_unit * unitRadius;
                const intersection_y = originY - (tan * tan_line_x_unit) * unitRadius;
                const canDraw = isFinite(tan) && Math.abs(tan * unitRadius) < H * 2;
                if (ui.checkboxes.sec.checked && canDraw) {
                    ctx.strokeStyle = style.getPropertyValue('--sec-color'); ctx.lineWidth = 5;
                    ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(tan_line_x_pixels, intersection_y); ctx.stroke();
                    ctx.fillStyle = ctx.strokeStyle; ctx.font = "bold 20px Arial";
                    ctx.save(); ctx.translate(originX + (tan_line_x_pixels - originX) / 2, originY + (intersection_y - originY) / 2);
                    ctx.rotate(-angleRad); ctx.fillText("sec", 15 * tan_line_x_unit, -10); ctx.restore();
                } else {
                    ctx.strokeStyle = style.getPropertyValue('--angle-color'); ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(pX, pY); ctx.stroke();
                }
                ctx.lineWidth = 5; ctx.font = "bold 20px Arial"; ctx.textAlign = 'center';
                if (ui.checkboxes.cos.checked) {
                    ctx.strokeStyle = style.getPropertyValue('--cos-color'); ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(pX, originY); ctx.stroke();
                    ctx.fillStyle = ctx.strokeStyle; ctx.fillText("cos", originX + (pX - originX) / 2, originY + 25);
                }
                if (ui.checkboxes.sin.checked) {
                    ctx.strokeStyle = style.getPropertyValue('--sin-color'); ctx.beginPath(); ctx.moveTo(pX, originY); ctx.lineTo(pX, pY); ctx.stroke();
                    ctx.fillStyle = ctx.strokeStyle; ctx.save(); ctx.translate(pX + 15, originY + (pY - originY) / 2); ctx.fillText("sin", 0, 5); ctx.restore();
                }
                if (ui.checkboxes.tan.checked && canDraw) {
                    ctx.strokeStyle = style.getPropertyValue('--tan-color'); ctx.beginPath(); ctx.moveTo(tan_line_x_pixels, originY); ctx.lineTo(tan_line_x_pixels, intersection_y); ctx.stroke();
                    ctx.fillStyle = ctx.strokeStyle; ctx.save(); ctx.translate(tan_line_x_pixels + 20 * tan_line_x_unit, originY + (intersection_y - originY)/2); ctx.fillText("tan", 0, 5); ctx.restore();
                }
            };
            drawCotCscModel = (angleRad, values) => {
                const { cos, sin, cot, csc } = values;
                const pX = originX + cos * unitRadius, pY = originY - sin * unitRadius;
                const tan_line_y_unit = (sin >= 0) ? 1 : -1;
                const tan_line_y_pixels = originY - tan_line_y_unit * unitRadius;
                const intersection_x = originX + (cot * tan_line_y_unit) * unitRadius;
                const canDraw = isFinite(cot) && Math.abs(cot * unitRadius) < W * 2;
                if (ui.checkboxes.csc.checked && canDraw) {
                    ctx.strokeStyle = style.getPropertyValue('--csc-color'); ctx.lineWidth = 5;
                    ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(intersection_x, tan_line_y_pixels); ctx.stroke();
                    ctx.fillStyle = ctx.strokeStyle; ctx.font = "bold 20px Arial";
                    ctx.save(); ctx.translate(originX + (intersection_x - originX) / 2, originY + (tan_line_y_pixels - originY) / 2);
                    ctx.rotate(-angleRad); ctx.fillText("cosec", 20, -10); ctx.restore();
                } else {
                     ctx.strokeStyle = style.getPropertyValue('--angle-color'); ctx.lineWidth = 2;
                     ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(pX, pY); ctx.stroke();
                }
                ctx.lineWidth = 5; ctx.font = "bold 20px Arial"; ctx.textAlign = 'center';
                if (ui.checkboxes.cos.checked) {
                    ctx.strokeStyle = style.getPropertyValue('--cos-color'); ctx.beginPath(); ctx.moveTo(originX, pY); ctx.lineTo(pX, pY); ctx.stroke();
                    ctx.fillStyle = ctx.strokeStyle; ctx.fillText("cos", originX + (pX - originX) / 2, pY - 10);
                }
                if (ui.checkboxes.sin.checked) {
                    ctx.strokeStyle = style.getPropertyValue('--sin-color'); ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(originX, pY); ctx.stroke();
                    ctx.fillStyle = ctx.strokeStyle; ctx.fillText("sin", originX - 25, originY + (pY-originY)/2);
                }
                if (ui.checkboxes.cot.checked && canDraw) {
                    ctx.strokeStyle = style.getPropertyValue('--cot-color'); ctx.beginPath(); ctx.moveTo(originX, tan_line_y_pixels); ctx.lineTo(intersection_x, tan_line_y_pixels); ctx.stroke();
                    ctx.fillStyle = ctx.strokeStyle; ctx.fillText("cot", originX + (intersection_x - originX)/2, tan_line_y_pixels - 15);
                }
            };

            function setupAndResizeCanvas() {
                // Get the display size of the canvas from CSS
                const size = canvas.getBoundingClientRect().width;
                // Set the rendering resolution to match the display size
                canvas.width = size;
                canvas.height = size;
                
                // Update global dimension variables
                W = canvas.width;
                H = canvas.height;
                originX = W / 2;
                originY = H / 2;
                unitRadius = W / 3.5;

                drawSimulation(angleDeg); // Redraw with new dimensions
            }

            // --- Event Listeners ---
            function getMousePos(canvasEl, evt) {
                const rect = canvasEl.getBoundingClientRect();
                const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
                const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
                return { x: clientX - rect.left, y: clientY - rect.top };
            }

            const onDragStart = (e) => {
                const pos = getMousePos(canvas, e);
                const currentAngleRad = angleDeg * Math.PI / 180;
                const pX = originX + Math.cos(currentAngleRad) * unitRadius;
                const pY = originY - Math.sin(currentAngleRad) * unitRadius;
                const dist = Math.hypot(pos.x - pX, pos.y - pY);
                if (dist < 20) { // Increased hit area for touch
                    isDragging = true;
                    canvas.style.cursor = 'grabbing';
                }
            };

            const onDragMove = (e) => {
                if (!isDragging) return;
                e.preventDefault(); // Prevent scrolling on mobile while dragging
                const pos = getMousePos(canvas, e);
                const dx = pos.x - originX;
                const dy = -(pos.y - originY);
                let newAngleRad = Math.atan2(dy, dx);
                let newAngleDeg = newAngleRad * 180 / Math.PI;
                if (newAngleDeg < 0) newAngleDeg += 360;
                angleDeg = newAngleDeg;
                drawSimulation(angleDeg);
            };
            
            const onDragEnd = () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            };

            // Mouse events
            canvas.addEventListener('mousedown', onDragStart);
            canvas.addEventListener('mousemove', onDragMove);
            canvas.addEventListener('mouseup', onDragEnd);
            canvas.addEventListener('mouseleave', onDragEnd);
            // Touch events for mobile
            canvas.addEventListener('touchstart', onDragStart, { passive: true });
            canvas.addEventListener('touchmove', onDragMove, { passive: false });
            canvas.addEventListener('touchend', onDragEnd);

            ui.resetButton.addEventListener('click', () => { angleDeg = DEFAULT_ANGLE; drawSimulation(angleDeg); });
            ui.modelSwitchers.forEach(switcher => {
                switcher.addEventListener('change', (e) => {
                    currentModel = e.target.value;
                    updateControlsForModel();
                    drawSimulation(angleDeg);
                });
            });
            Object.values(ui.checkboxes).forEach(cb => cb.addEventListener('change', () => drawSimulation(angleDeg)));

            // --- Initial State ---
            window.addEventListener('resize', setupAndResizeCanvas);
            updateControlsForModel();
            setupAndResizeCanvas(); // Initial call to set size and draw
        });
    </script>
</body>
</html>
